{"version":3,"sources":["knot.js"],"names":["scope","factory","name","module","exports","define","amd","this","JSONFormatter","isSpecial","token","special","indexOf","addQuotation","force","quote","quotation","pattern","noquote","test","removeTrailing","result","trailer","substr","length","escapeQuotedInput","list","character","shift","push","escape","join","compiler","concat","tokenize","input","i","prototype","__instance","formatter","prepare","replace","match","symbol","parse","JSON","global","Knot","init","compatible","json","buffer","defaults","greedy","attribute","extension","rAF","requestAnimationFrame","f","setTimeout","document","addEventListener","ready","Object","castToArray","cast","Array","slice","call","error","arg","knot","apply","handler","console","textNodes","element","node","walker","createTreeWalker","NodeFilter","SHOW_TEXT","nextNode","attributes","nodeType","childNodes","hasAttribute","querySelectorAll","splitter","nodeValue","content","index","splitText","remainder","original","placeholders","forEach","options","p","model","key","descriptor","prepared","enumerable","value","writable","delegate","get","set","defineProperties","getDelegate","nest","getOwnPropertyDescriptor","data","elements","subscriber","accessor","update","fn","arguments","provider","callback","item","elm","observe","undefined","access","subscribe","subscribers","sub","persist","delegation","current","type","text","observer","MutationObserver","webkitMutationObserver","textObserverConfig","characterData","characterDataOldValue","mutations","mutation","target","e","newValue","tie","pop","body","ties","placeholder","split","initial","delegated","defineProperty","config","contains","getAttribute","keys","ex","ancestry","parentNode","filter","register","setAttribute","removeAttribute","propagate","classList","RegExp","className","after","firstChild","createTextNode","insertBefore","appendChild","refine","method","window","Error","output","createDocumentFragment","collection","$item","$parent","$index","template","cloneNode","lastChild","removeChild","part","k","nodeName","multiple","handle","property","selection","defaultOption","label","offset","Option","selectedIndex","select","selected","delegatedList","change"],"mappings":"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","file":"knot.min.js","sourcesContent":["\n//BEGIN INCLUDE: lib/json-formatter\n/**\n *  Format a string containing (valid) js variables into proper JSON so it can be handled by JSON.parse\n *  @package    JSONFormatter\n *  @author     Rogier Spieker <rogier@konfirm.eu>\n */\n(function(scope, factory) {\n\t// $lab:coverage:off$\n\tvar name = 'JSONFormatter';\n\n\tif (typeof module === 'object' && typeof module.exports === 'object') {\n\t\tmodule.exports = factory();\n\t}\n\telse if (typeof define === 'function' && define.amd) {\n\t\tdefine(name, factory);\n\t}\n\telse {\n\t\t(typeof exports === 'object' ? exports : scope)[name] = factory();\n\t}\n\t// $lab:coverage:on$\n})(this, function() {\n\n\tfunction JSONFormatter() {\n\t\t//  Implement a Singleton pattern and allow JSONFormatter to be invoked without the `new` keyword\n\t\tif (typeof JSONFormatter.prototype.__instance !== 'undefined' || !(this instanceof JSONFormatter)) {\n\t\t\treturn JSONFormatter.prototype.__instance || new JSONFormatter();\n\t\t}\n\t\tJSONFormatter.prototype.__instance = this;\n\n\t\tvar formatter = this,\n\t\t\tspecial = '\\'\":,{}[] ',\n\t\t\tquotation = '\"',\n\t\t\tpattern = {\n\t\t\t\tescape: /[\"\\\\\\/\\b\\f\\n\\r\\t]/,\n\t\t\t\tnoquote: /^(?:true|false|null|-?[0-9]+(?:\\.[0-9]+)?)$/i,\n\t\t\t\ttrailer: /[,]+$/\n\t\t\t};\n\n\t\t/**\n\t\t *  Determine is a token is a special character\n\t\t *  @name    isSpecial\n\t\t *  @access  internal\n\t\t *  @param   string  token\n\t\t *  @return  bool  special\n\t\t */\n\t\tfunction isSpecial(token) {\n\t\t\treturn special.indexOf(token) >= 0;\n\t\t}\n\n\t\t/**\n\t\t *  Add quotes if required\n\t\t *  @name    addQuotation\n\t\t *  @access  internal\n\t\t *  @param   string  token\n\t\t *  @param   bool    force\n\t\t *  @return  string  JSON-token\n\t\t */\n\t\tfunction addQuotation(token, force) {\n\t\t\tvar quote = quotation;\n\n\t\t\t//  if quotation is not enforced, we must skip application of quotes for certain tokens\n\t\t\tif (!force && (isSpecial(token) || pattern.noquote.test(token))) {\n\t\t\t\tquote = '';\n\t\t\t}\n\n\t\t\treturn quote + token + quote;\n\t\t}\n\n\t\t/**\n\t\t *  Remove trailing commas from the result stack\n\t\t *  @name    removeTrailing\n\t\t *  @access  internal\n\t\t *  @param   Array  result\n\t\t *  @return  Array  result\n\t\t */\n\t\tfunction removeTrailing(result) {\n\t\t\treturn pattern.trailer.test(result) ? removeTrailing(result.substr(0, result.length - 1)) : result;\n\t\t}\n\n\t\t/**\n\t\t *  Handle a quoted string, ensuring proper escaping for double quoted strings\n\t\t *  @name    escapeQuotedInput\n\t\t *  @access  internal\n\t\t *  @param   string  token\n\t\t *  @array   Array   list\n\t\t *  @return  Array   result\n\t\t */\n\t\tfunction escapeQuotedInput(token, list) {\n\t\t\tvar result = [],\n\t\t\t\tcharacter;\n\n\t\t\t//  token is the initial (opening) quotation character, we are not (yet) interested in this,\n\t\t\t//  as we need to process the stuff in list, right until we find a matching token\n\t\t\twhile (list.length) {\n\t\t\t\tcharacter = list.shift();\n\n\t\t\t\t//  reduce provided escaping\n\t\t\t\tif (character[character.length - 1] === '\\\\') {\n\t\t\t\t\tif (!pattern.escape.test(list[0])) {\n\t\t\t\t\t\t//  remove the escape character\n\t\t\t\t\t\tcharacter = character.substr(0, character.length - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\t//  add the result\n\t\t\t\t\tresult.push(character);\n\n\t\t\t\t\t//  while we are at it, we may aswel move the (at least previously) escaped\n\t\t\t\t\t//  character to the result\n\t\t\t\t\tresult.push(list.shift());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (character === token) {\n\t\t\t\t\t//  with the escaping taken care of, we now know the string has ended\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tresult.push(character);\n\t\t\t}\n\n\t\t\treturn addQuotation(result.join(''));\n\t\t}\n\n\t\t/**\n\t\t *  Compile the JSON-formatted string from a list of 'tokenized' data\n\t\t *  @name    compiler\n\t\t *  @access  internal\n\t\t *  @param   Array   list\n\t\t *  @return  string  JSON-formatted\n\t\t */\n\t\tfunction compiler(list) {\n\t\t\tvar result = '',\n\t\t\t\ttoken;\n\n\t\t\twhile (list.length) {\n\t\t\t\ttoken = list.shift();\n\n\t\t\t\tswitch (token) {\n\t\t\t\t\t//  ignore whitespace outside of quoted patterns\n\t\t\t\t\tcase ' ':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//  remove any trailing commas and whitespace\n\t\t\t\t\tcase '}':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tresult = removeTrailing(result).concat([token]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//  add/remove escaping\n\t\t\t\t\tcase '\"':\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\tresult += escapeQuotedInput(token, list);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//  determine if the value needs to be quoted (always true if the next item in the list is a separator)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tresult += addQuotation(token, list[0] === ':');\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Tokenize the input, adding each special character to be its own item in the resulting array\n\t\t *  @name    tokenize\n\t\t *  @access  internal\n\t\t *  @param   string  input\n\t\t *  @result  Array   tokens\n\t\t */\n\t\tfunction tokenize(input) {\n\t\t\tvar result = [],\n\t\t\t\ti;\n\n\t\t\t//  check each character in the string\n\t\t\tfor (i = 0; i < input.length; ++i) {\n\t\t\t\t//  if there is not result or the current or previous input is special, we create a new result item\n\t\t\t\tif (result.length === 0 || isSpecial(input[i]) || isSpecial(result[result.length - 1])) {\n\t\t\t\t\tresult.push(input[i]);\n\t\t\t\t}\n\t\t\t\t//  extend the previous item\n\t\t\t\telse {\n\t\t\t\t\tresult[result.length - 1] += input[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Prepare a string to become a JSON-representation\n\t\t *  @name    prepare\n\t\t *  @access  public\n\t\t *  @param   string  input\n\t\t *  @return  string  JSON-formatted\n\t\t */\n\t\tformatter.prepare = function(input) {\n\t\t\t//  tokenize the input and feed it to the compiler in one go\n\t\t\treturn compiler(tokenize(input))\n\t\t\t\t//  determine whether we are dealing with an Object or Array notation\n\t\t\t\t.replace(/^.*?([:,]).*$/, function(match, symbol) {\n\t\t\t\t\tvar character = symbol === ':' ? '{}' : '[]';\n\n\t\t\t\t\t//  figure out if the notation should be added or may be skipped\n\t\t\t\t\treturn match[0] !== character[0] ? character[0] + removeTrailing(match) + character[1] : match;\n\t\t\t\t})\n\t\t\t;\n\t\t};\n\n\t\t/**\n\t\t *  Prepare a string and parse it using JSON.parse\n\t\t *  @name    parse\n\t\t *  @access  public\n\t\t *  @param   string  input\n\t\t *  @return  mixed   parsed\n\t\t */\n\t\tformatter.parse = function(input) {\n\t\t\treturn JSON.parse(formatter.prepare(input));\n\t\t};\n\t}\n\n\t//  expose the interface\n\treturn JSONFormatter;\n});\n\n//END INCLUDE: lib/json-formatter [700.36µs, 5.89KB]\n;(function(global, factory) {\n\t'use strict';\n\n\t/**\n\t *  Simplified data-binding, never using eval\n\t *  (e.g. Content-Security-Policy does not need the 'unsafe-eval' flag)\n\t *  @package  Knot\n\t */\n\tfunction Knot() {\n\t\tvar knot = this,\n\t\t\tjson, buffer;\n\n\t\t/**\n\t\t *  Initialiser\n\t\t *  @name    init\n\t\t *  @access  internal\n\t\t *  @return  void\n\t\t */\n\t\tfunction init() {\n\t\t\tif (!compatible()) {\n\t\t\t\treturn setTimeout(function() {\n\t\t\t\t\tready('Unsupported browser');\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\t//  the JSON formatter\n\t\t\tjson = new JSONFormatter();\n\n\t\t\t//  the default options\n\t\t\tbuffer = {\n\t\t\t\tdefaults: {\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\tattribute: 'data-knot'\n\t\t\t\t},\n\t\t\t\textension: {},\n\t\t\t\trAF: global.requestAnimationFrame || function(f) {\n\t\t\t\t\tsetTimeout(f, 16);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t//  add the DOMContentLoaded event to the document, so we can trigger the 'ready' handlers early on\n\t\t\tdocument.addEventListener('DOMContentLoaded', function() {\n\t\t\t\t//  call any registered 'ready' handler\n\t\t\t\tready();\n\n\t\t\t\t//  mark the internal 'ready' buffer as bool true so any callback added after knot\n\t\t\t\t//  has become ready can be invoked (almost) immediately\n\t\t\t\tbuffer.ready = true;\n\t\t\t}, false);\n\n\t\t\t//  register the default extensions\n\t\t\tfactory(extension);\n\t\t}\n\n\t\t/**\n\t\t *  Basic compatibility check\n\t\t *  @name    compatible\n\t\t *  @access  internal\n\t\t *  @return  void  [throws Error is not compatible]\n\t\t */\n\t\tfunction compatible() {\n\t\t\tvar result = true;\n\n\t\t\tresult = result && 'addEventListener' in document;\n\t\t\tresult = result && 'defineProperties' in Object;\n\t\t\tresult = result && 'getOwnPropertyDescriptor' in Object;\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Convert given array-like value to be a true array\n\t\t *  @name    castToArray\n\t\t *  @access  internal\n\t\t *  @param   Array-like  value\n\t\t *  @return  Array  value\n\t\t */\n\t\tfunction castToArray(cast) {\n\t\t\treturn Array.prototype.slice.call(cast);\n\t\t}\n\n\t\t/**\n\t\t *  Invoke all provided functions as callback\n\t\t *  @name    ready\n\t\t *  @access  internal\n\t\t *  @param   string  error\n\t\t *  @return  Knot    instance\n\t\t */\n\t\tfunction ready(error, list) {\n\t\t\tvar arg = [error, knot];\n\n\t\t\tlist = list || buffer && 'ready' in buffer ? buffer.ready : false;\n\n\t\t\tif (list) {\n\t\t\t\tfor (var i = 0; i < list.length; ++i) {\n\t\t\t\t\tlist[i].apply(null, arg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn knot;\n\t\t}\n\n\t\t/**\n\t\t *  Obtain and/or register an extension to be defined in the data attribute\n\t\t *  @name    extension\n\t\t *  @access  internal\n\t\t *  @param   string    name\n\t\t *  @param   function  handler  [optional, default undefined - obtain the extension]\n\t\t *  @return  function  handler\n\t\t */\n\t\tfunction extension(name, handler) {\n\t\t\tif (handler) {\n\t\t\t\tbuffer.extension[name] = handler;\n\t\t\t}\n\n\t\t\tif (!(name in buffer.extension)) {\n\t\t\t\treturn function() {\n\t\t\t\t\tconsole.error('Knot: Unknown extension \"' + name + '\"');\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn buffer.extension[name];\n\t\t}\n\n\t\t/**\n\t\t *  Obtain all textNodes residing within given element\n\t\t *  @name    textNodes\n\t\t *  @access  internal\n\t\t *  @param   DOMElement\n\t\t *  @return  Array  textNodes\n\t\t */\n\t\tfunction textNodes(element) {\n\t\t\tvar result = [],\n\t\t\t\twalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false),\n\t\t\t\tnode;\n\n\t\t\twhile ((node = walker.nextNode())) {\n\t\t\t\tresult.push(node);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Obtain all elements containing the data attribute residing within given element\n\t\t *  @name    attributes\n\t\t *  @access  internal\n\t\t *  @param   DOMElement\n\t\t *  @return  Array  textNodes\n\t\t */\n\t\tfunction attributes(element) {\n\t\t\tvar result = [],\n\t\t\t\tlist, i;\n\n\t\t\tswitch (element.nodeType) {\n\t\t\t\tcase 11:  //  DocumentFragment\n\t\t\t\t\tfor (i = 0; i < element.childNodes.length; ++i) {\n\t\t\t\t\t\tresult = result.concat(attributes(element.childNodes[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  //  DOMElement\n\t\t\t\t\tif (element.hasAttribute(buffer.defaults.attribute)) {\n\t\t\t\t\t\tresult.push(element);\n\t\t\t\t\t}\n\t\t\t\t\t/*falls through*/\n\t\t\t\tcase 9:  //  DOMDocument\n\t\t\t\t\tlist = element.querySelectorAll('[' + buffer.defaults.attribute + ']');\n\t\t\t\t\tfor (i = 0; i < list.length; ++i) {\n\t\t\t\t\t\tresult.push(list[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Split a DOMText node into placeholder and non-placeholder parts, returning an array of all DOMText nodes\n\t\t *  containing a placeholder\n\t\t *  @name   splitter\n\t\t *  @access internal\n\t\t *  @param  DOMText node\n\t\t *  @return array   DOMText nodes\n\t\t */\n\t\tfunction splitter(node) {\n\t\t\tvar match = node.nodeValue.match(/(\\{([^\\{]+)\\})/),\n\t\t\t\tcontent = match ? (match.index === 0 ? node : node.splitText(match.index)) : null,\n\t\t\t\tremainder = match ? content.splitText(match[1].length) : null,\n\t\t\t\tresult = content ? [content] : [];\n\n\t\t\tif (content) {\n\t\t\t\tcontent.original = content.nodeValue;\n\t\t\t}\n\n\t\t\tif (remainder) {\n\t\t\t\tresult = result.concat(splitter(remainder));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Obtain all placeholder DOMText nodes within given element\n\t\t *  @name    placeholders\n\t\t *  @access  internal\n\t\t *  @param   DOMNode element\n\t\t *  @return  array   DOMText nodes\n\t\t */\n\t\tfunction placeholders(element) {\n\t\t\tvar result = [];\n\n\t\t\ttextNodes(element).forEach(function(node) {\n\t\t\t\tresult = result.concat(splitter(node));\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Populate an options object based on the defaults and override any provided setting\n\t\t *  @name    defaults\n\t\t *  @access  internal\n\t\t *  @param   Object  options  [optional, default undefined - the full default options]\n\t\t *  @result  Object  options\n\t\t */\n\t\tfunction defaults(options) {\n\t\t\tvar p;\n\n\t\t\tif (options && typeof options === 'object') {\n\t\t\t\tfor (p in options) {\n\t\t\t\t\tbuffer.defaults[p] = options[p];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buffer.defaults;\n\t\t}\n\n\t\t/**\n\t\t *  Prepare delegation for all keys of the provided model\n\t\t *  @name    prepare\n\t\t *  @access  internal\n\t\t *  @param   Object  model\n\t\t *  @return  Object  prepared model\n\t\t */\n\t\tfunction prepare(model) {\n\t\t\tvar descriptor = {\n\t\t\t\t\tprepared: {enumerable: false, value: true}\n\t\t\t\t},\n\t\t\t\tkey, handler;\n\n\t\t\tif (typeof model === 'object' && !('prepared' in model && model.prepared)) {\n\t\t\t\tfor (key in model) {\n\t\t\t\t\t//  skip any previously prepared key\n\t\t\t\t\t//  we detect \"our own\" delegation by looking for the provider in the handler function\n\t\t\t\t\tif (typeof model[key] !== 'function' || !('provider' in model[key])) {\n\t\t\t\t\t\tif (typeof model[key] === 'function') {\n\t\t\t\t\t\t\tdescriptor[key] = {\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\twritable: false,\n\t\t\t\t\t\t\t\tvalue: model[key]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof model[key] === 'object' && !(model[key] instanceof Array)) {\n\t\t\t\t\t\t\tdescriptor[key] = {\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\twritable: false,\n\t\t\t\t\t\t\t\tvalue: prepare(model[key])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thandler = delegate(model[key], model);\n\n\t\t\t\t\t\t\tdescriptor[key] = {\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tget: handler,\n\t\t\t\t\t\t\t\tset: handler\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ('scope' in model[key] && !model[key].scope()) {\n\t\t\t\t\t\tmodel[key].scope(model);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tObject.defineProperties(model, descriptor);\n\t\t\t}\n\n\t\t\treturn model;\n\t\t}\n\n\t\t/**\n\t\t *  Obtain the delegate function applied to a model property by Knot\n\t\t *  @name    getDelegate\n\t\t *  @access  internal\n\t\t *  @param   object    model\n\t\t *  @param   string    key\n\t\t *  @return  function  delegate  [false, if no delegate was found]\n\t\t */\n\t\tfunction getDelegate(model, key) {\n\t\t\tvar result = false,\n\t\t\t\tdescriptor, nest;\n\n\t\t\tif (key in model) {\n\t\t\t\t//  if a model key is an explicitly assigned delegate, we utilize it\n\t\t\t\tif (typeof model[key] === 'function' && 'element' in model[key]) {\n\t\t\t\t\tresult = model[key];\n\t\t\t\t}\n\t\t\t\t//  otherwise we need to get the property descriptor first\n\t\t\t\telse {\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(model, key);\n\t\t\t\t\tresult = descriptor.get;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnest = key.indexOf('.');\n\t\t\t\tif (nest > 0 && key.substr(0, nest) in model) {\n\t\t\t\t\treturn getDelegate(model[key.substr(0, nest)], key.substr(nest + 1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t *  Create a delegation method for the given data\n\t\t *  @name    delegate\n\t\t *  @access  internal\n\t\t *  @param   mixed     data\n\t\t *  @param   Object    scope\n\t\t *  @return  function  delegate\n\t\t */\n\t\tfunction delegate(data, scope) {\n\t\t\tvar elements = [],\n\t\t\t\tsubscriber = [],\n\t\t\t\taccessor = [],\n\t\t\t\tvalue = update(data),\n\t\t\t\tfn = function() {\n\t\t\t\t\tif (arguments.length) {\n\t\t\t\t\t\tdata  = fn.provider(arguments[0]);\n\t\t\t\t\t\tvalue = update.apply(scope, [data, elements, subscriber, 'delegate']);\n\t\t\t\t\t}\n\t\t\t\t\telse if (accessor.length) {\n\t\t\t\t\t\taccessor.forEach(function(callback) {\n\t\t\t\t\t\t\tcallback.apply(null, [data]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\n\t\t\t//  if we are dealing with arrays, we'd like to know about mutations\n\t\t\tif (data instanceof Array) {\n\t\t\t\t['copyWithin', 'fill', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].forEach(function(key) {\n\t\t\t\t\tif (typeof data[key] === 'function') {\n\t\t\t\t\t\tdata['_' + key] = data[key];\n\t\t\t\t\t\tdata[key] = function() {\n\t\t\t\t\t\t\tvar result = data['_' + key].apply(data, arguments);\n\n\t\t\t\t\t\t\t//  map the changes\n\t\t\t\t\t\t\tdata.forEach(function(item, index) {\n\t\t\t\t\t\t\t\tdata[index] = prepare(item);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tupdate.apply(scope, [data, elements, subscriber, key]);\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tdata.forEach(function(item, index) {\n\t\t\t\t\tdata[index] = prepare(item);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t//  The main provider, responsible for handling all value changes\n\t\t\tfn.provider = function(data) {\n\t\t\t\tvar callback;\n\n\t\t\t\tif (typeof data === 'function') {\n\t\t\t\t\tcallback = data;\n\t\t\t\t\tdata = function() {\n\t\t\t\t\t\treturn update.apply(scope, [callback.apply(null, arguments), elements, subscriber, 'function']);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\t//  Scope getter/setter (setting only allowed once)\n\t\t\tfn.scope = function() {\n\t\t\t\tif (!scope && arguments.length) {\n\t\t\t\t\tscope = arguments[0];\n\t\t\t\t}\n\n\t\t\t\treturn scope;\n\t\t\t};\n\n\t\t\t//  Add an element to the list and ensure the correct (initial) value\n\t\t\tfn.element = function() {\n\t\t\t\tvar list;\n\n\t\t\t\tif (arguments.length) {\n\t\t\t\t\tlist = castToArray(arguments);\n\n\t\t\t\t\tlist.forEach(function(elm) {\n\t\t\t\t\t\tobserve(elm, fn);\n\t\t\t\t\t});\n\n\t\t\t\t\tupdate.apply(scope, [data, list, undefined, 'element']);\n\t\t\t\t\telements = elements.concat(list);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t};\n\n\t\t\t//  Subscribe a handler which receives all 'reads'\n\t\t\tfn.access = function() {\n\t\t\t\taccessor = accessor.concat(castToArray(arguments));\n\n\t\t\t\treturn fn;\n\t\t\t};\n\n\t\t\t//  subscribe a handler which receives all changes\n\t\t\tfn.subscribe = function() {\n\t\t\t\tsubscriber = subscriber.concat(castToArray(arguments));\n\n\t\t\t\treturn fn;\n\t\t\t};\n\n\t\t\t//  finally: call the fn.provider to properly associate the data\n\t\t\tfn.provider(data);\n\n\t\t\treturn fn;\n\t\t}\n\n\t\t/**\n\t\t *  Update zero or more elements (optionally passed on to subscribers) and return the value\n\t\t *  @name    update\n\t\t *  @access  internal\n\t\t *  @param   mixed   data\n\t\t *  @param   array   elements     [optional, default undefined - nothing to update]\n\t\t *  @param   Array   subscribers  [optional, default undefined - no pass through subscribers]\n\t\t *  @param   string  name         [optional, default undefined - 'unknown']\n\t\t *  @return  mixed   value\n\t\t */\n\t\tfunction update(data, elements, subscribers, name) {\n\t\t\tvar value = typeof data === 'function' ? data() : data,\n\t\t\t\tmodel = this,\n\t\t\t\tnodeValue;\n\n\t\t\tif (subscribers) {\n\t\t\t\tsubscribers.forEach(function(sub) {\n\t\t\t\t\tvar result = sub.apply(null, [value, model, name]);\n\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (elements) {\n\t\t\t\tnodeValue = '' + value;\n\t\t\t\telements.forEach(function(element) {\n\t\t\t\t\tif (nodeValue !== element.nodeValue) {\n\t\t\t\t\t\tbuffer.rAF.apply(global, [function() {\n\t\t\t\t\t\t\telement.nodeValue = nodeValue;\n\t\t\t\t\t\t}]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn typeof data === 'function' ? data : value;\n\t\t}\n\n\t\t/**\n\t\t *  Persist a value to the model\n\t\t *  @name    persist\n\t\t *  @access  internal\n\t\t *  @param   function  delegate\n\t\t *  @param   mixed     value\n\t\t *  @return  void\n\t\t *  @note    This function is triggered from MutationObservers/-Events\n\t\t */\n\t\tfunction persist(delegation, value) {\n\t\t\tvar current = delegation(),\n\t\t\t\ttype = typeof current;\n\n\t\t\tif (type === 'object') {\n\t\t\t\ttype = type instanceof Array ? 'array' : type;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'function':\n\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\tdelegation(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'number':\n\t\t\t\t\tif (+current !== +value) {\n\t\t\t\t\t\tdelegation(+value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif (!!current !== !!value) {\n\t\t\t\t\t\tdelegation(!!value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\t\t/*falls through*/\n\t\t\t\tdefault:\n\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\tdelegation(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *  Observe the DOMElement(s) bound to the model key and persist changes from outside Knot\n\t\t *  @name    observe\n\t\t *  @access  internal\n\t\t *  @param   DOMText   text\n\t\t *  @param   function  delegate\n\t\t *  @return  void\n\t\t */\n\t\tfunction observe(text, delegation) {\n\t\t\tvar observer;\n\n\t\t\tif (!('observer' in buffer)) {\n\t\t\t\tbuffer.observer = global.MutationObserver || global.webkitMutationObserver || false;\n\t\t\t\tbuffer.textObserverConfig = {\n\t\t\t\t\tcharacterData: true,\n\t\t\t\t\tcharacterDataOldValue: true\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (buffer.observer) {\n\t\t\t\tobserver = new buffer.observer(function(mutations) {\n\t\t\t\t\tmutations.forEach(function(mutation) {\n\t\t\t\t\t\tpersist(delegation, mutation.target.nodeValue);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tobserver.observe(text, buffer.textObserverConfig);\n\t\t\t}\n\t\t\telse if (text.addEventListener) {\n\t\t\t\ttext.addEventListener('DOMCharacterDataModified', function(e) {\n\t\t\t\t\tif (e.newValue) {\n\t\t\t\t\t\tpersist(delegation, e.newValue);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *  Register one or more functions to be called once Knot is ready to\n\t\t *  tie together models and elements\n\t\t *  @name    ready\n\t\t *  @access  public\n\t\t *  @param   function ...  [variadic, provide as many functions you need]\n\t\t *  @return  Knot instance [chainable]\n\t\t */\n\t\tknot.ready = function() {\n\t\t\tvar arg = castToArray(arguments);\n\n\t\t\tif (!buffer) {\n\t\t\t\tbuffer = {};\n\t\t\t}\n\t\t\tif (!('ready' in buffer)) {\n\t\t\t\tbuffer.ready = [];\n\t\t\t}\n\t\t\telse if (buffer.ready === true) {\n\t\t\t\treturn ready(arg);\n\t\t\t}\n\n\t\t\tbuffer.ready = buffer.ready.concat(arg);\n\n\t\t\treturn knot;\n\t\t};\n\n\t\t/**\n\t\t *  Tie a model to zero or more elements\n\t\t *  @name    tie\n\t\t *  @access  public\n\t\t *  @param   Object      model\n\t\t *  @param   DOMElement  ...     [variadic, zero or more DOMElement instances]\n\t\t *  @param   Object      options [optional, default undefined - default options]\n\t\t *  @return  void\n\t\t *  @note    If no DOMElements are provided, the model will be bound to the entire document\n\t\t */\n\t\tknot.tie = function() {\n\t\t\tvar arg = castToArray(arguments),\n\t\t\t\tmodel = typeof arg[0] === 'object' && !('nodeType' in arg[0]) ? arg.shift() : {},\n\t\t\t\toptions = defaults(arg.length > 0 && (typeof arg[arg.length - 1] === 'object' && !('nodeType' in arg[arg.length - 1])) ? arg.pop() : {}),\n\t\t\t\tnode;\n\n\t\t\tif (arg.length <= 0) {\n\t\t\t\targ.push(document.body);\n\t\t\t}\n\n\t\t\tmodel = prepare(model);\n\n\t\t\tif (!('ties' in buffer)) {\n\t\t\t\tbuffer.ties = [];\n\t\t\t}\n\t\t\tbuffer.ties.push({model: model, target: arg.slice()});\n\n\t\t\twhile (arg.length) {\n\t\t\t\tnode = arg.shift();\n\n\t\t\t\tplaceholders(node)\n\t\t\t\t\t.forEach(function(text) {\n\t\t\t\t\t\tvar placeholder = text.nodeValue.substr(1, text.nodeValue.length - 2).split(/:/),\n\t\t\t\t\t\t\tkey = placeholder.shift(),\n\t\t\t\t\t\t\tinitial = placeholder.length ? placeholder.join(':') : '',\n\t\t\t\t\t\t\tdelegated = getDelegate(model, key);\n\n\t\t\t\t\t\tif (delegated) {\n\t\t\t\t\t\t\tif (!delegated()) {\n\t\t\t\t\t\t\t\tdelegated(initial);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (options.greedy) {\n\t\t\t\t\t\t\tdelegated = delegate(initial, model);\n\t\t\t\t\t\t\tObject.defineProperty(model, key, {\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tget: delegated,\n\t\t\t\t\t\t\t\tset: delegated\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//  if Knot created the delegate, we should register the element to the delegation\n\t\t\t\t\t\tif (delegated) {\n\t\t\t\t\t\t\tdelegated.element(text);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t;\n\n\t\t\t\tattributes(node)\n\t\t\t\t\t.forEach(function(target) {\n\t\t\t\t\t\tvar config;\n\n\t\t\t\t\t\tif (document.body.contains(target)) {\n \t\t\t\t\t\t\tconfig = json.parse(target.getAttribute(buffer.defaults.attribute));\n\n \t\t\t\t\t\t\tif (typeof config === 'object') {\n\t\t\t\t\t\t\t\tObject.keys(config)\n\t\t\t\t\t\t\t\t\t.forEach(function(key) {\n\t\t\t\t\t\t\t\t\t\tvar ex = extension(key);\n\n\t\t\t\t\t\t\t\t\t\tex(target, model, config[key], getDelegate);\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t;\n\t\t\t}\n\n\t\t\treturn model;\n\t\t};\n\n\t\t/**\n\t\t *  Get/set the default options\n\t\t *  @name    defaults\n\t\t *  @param   Object  options  [optional, default undefined - do not set anything]\n\t\t *  @return  Object  default options\n\t\t */\n\t\tknot.defaults = function(options) {\n\t\t\tif (options && typeof options === 'object') {\n\t\t\t\tbuffer.defaults = defaults(options);\n\t\t\t}\n\n\t\t\treturn buffer.defaults;\n\t\t};\n\n\t\t/**\n\t\t *  Create a delegate for given data\n\t\t *  @name    delegate\n\t\t *  @access  public\n\t\t *  @param   mixed     data\n\t\t *  @return  function  delegate\n\t\t */\n\t\tknot.delegate = delegate;\n\t\tknot.delegate.get = getDelegate;\n\n\t\t/**\n\t\t *  Register an extension to handle settings from a data attribute\n\t\t *  @name    extension\n\t\t *  @access  public\n\t\t *  @param   string    name\n\t\t *  @param   function  handler\n\t\t *  @return  function  handler\n\t\t */\n\t\tknot.extension = extension;\n\n\t\t/**\n\t\t *  Obtain the model(s) influencing the provided element\n\t\t *  @name    ties\n\t\t *  @access  public\n\t\t *  @param   DOMNode  element\n\t\t *  @return  Array    models\n\t\t */\n\t\tknot.ties = function(element) {\n\t\t\tvar result = [],\n\t\t\t\tancestry = [element];\n\n\t\t\tif ('ties' in buffer) {\n\t\t\t\t//  obtain a the ancestry (parent relations) for the given element\n\t\t\t\twhile (ancestry[ancestry.length - 1].parentNode) {\n\t\t\t\t\tancestry.push(ancestry[ancestry.length - 1].parentNode);\n\t\t\t\t}\n\n\t\t\t\t//  iterator over each tied model\n\t\t\t\tbuffer.ties.forEach(function(tie) {\n\t\t\t\t\tvar list = tie.target.filter(function(node) {\n\t\t\t\t\t\t\treturn ancestry.indexOf(node) >= 0;\n\t\t\t\t\t\t});\n\n\t\t\t\t\tif (list.length) {\n\t\t\t\t\t\tresult.push(tie.model);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\t//  initialise knot\n\t\tinit();\n\t}\n\n\t//  register the (only) Knot instance to the global scope\n\tglobal.knot = new Knot();\n\n})(this, function(register) {\n\n\n\t//BEGIN INCLUDE: extension/attribute\n\tregister('attribute', function(element, model, config, delegation) {\n\t\t'use strict';\n\n\t\tfunction update(key, value) {\n\t\t\tif (value) {\n\t\t\t\telement.setAttribute(key, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.removeAttribute(key);\n\t\t\t}\n\t\t}\n\n\t\tObject.keys(config)\n\t\t\t.forEach(function(key) {\n\t\t\t\tvar delegated = delegation(model, config[key]);\n\n\t\t\t\t//  If knot created delegation for the key, we subscribe to changes\n\t\t\t\tif (delegated) {\n\t\t\t\t\t//  subscribe to value changes\n\t\t\t\t\tdelegated.subscribe(function(value) {\n\t\t\t\t\t\tif (element.getAttribute(key) !== value) {\n\t\t\t\t\t\t\tupdate(key, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t//  set the attribute based on the model value\n\t\t\t\tupdate(key, model[config[key]]);\n\t\t\t})\n\t\t;\n\t});\n\n\t//END INCLUDE: extension/attribute [124.11µs, 682.00bytes]\n\t//BEGIN INCLUDE: extension/style\n\tregister('style', function(element, model, config, delegation) {\n\t\t'use strict';\n\n\t\tObject.keys(config)\n\t\t\t.forEach(function(key) {\n\t\t\t\tvar delegated = delegation(model, config[key]),\n\t\t\t\t\tpropagate = function(value) {\n\t\t\t\t\t\tvar list;\n\n\t\t\t\t\t\tif ('classList' in element) {\n\t\t\t\t\t\t\telement.classList[!!value ? 'add' : 'remove'](key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//  the old-fashioned method of applying classes\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (!pattern) {\n\t\t\t\t\t\t\t\tpattern = new RegExp('(?:^|\\\\s+)' + key + '(\\\\s+|$)');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlist = element.className.replace(pattern, function(match, after) {\n\t\t\t\t\t\t\t\treturn after || '';\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\telement.className = list + (!!value ? ' ' + key : '');\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tpattern;\n\n\t\t\t\t//  If knot created delegation for the key, we subscribe to changes\n\t\t\t\tif (delegated) {\n\t\t\t\t\t//  subscribe to value changes\n\t\t\t\t\tdelegated.subscribe(propagate);\n\t\t\t\t}\n\n\t\t\t\t//  set the attribute based on the model value\n\t\t\t\tpropagate(model[config[key]]);\n\t\t\t})\n\t\t;\n\t});\n\n\t//END INCLUDE: extension/style [79.59µs, 954.00bytes]\n\t//BEGIN INCLUDE: extension/text\n\tregister('text', function(element, model, key, delegation) {\n\t\t'use strict';\n\n\t\tvar delegated = delegation(model, key),\n\t\t\ttext = element.firstChild && element.firstChild.nodeType === 3 ? element.firstChild : document.createTextNode(delegated ? delegated() : ''),\n\t\t\tpropagate = function() {\n\t\t\t\tif (text.parentNode !== element) {\n\t\t\t\t\tif (element.firstChild) {\n\t\t\t\t\t\telement.insertBefore(text, element.firstChild);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\telement.appendChild(text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (delegated) {\n\t\t\tdelegated.subscribe(propagate);\n\t\t\tdelegated.element(text);\n\t\t}\n\n\t\tpropagate(model[key]);\n\t});\n\n\t//END INCLUDE: extension/text [156.43µs, 585.00bytes]\n\t//BEGIN INCLUDE: extension/each\n\tregister('each', function(element, model, key, delegation) {\n\t\t'use strict';\n\n\t\tvar template = [],\n\t\t\ttarget, delegated;\n\n\t\tif (typeof key === 'object') {\n\t\t\ttarget = key.target || false;\n\n\t\t\tif (!target) {\n\t\t\t\tthrow new Error('Missing target for \"each\"');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttarget = key;\n\t\t}\n\n\t\tdelegated = delegation(model, target);\n\n\t\t//  absorb all childNodes into the template\n\t\twhile (element.firstChild) {\n\t\t\ttemplate.push(element.removeChild(element.firstChild).cloneNode(true));\n\t\t}\n\n\t\tfunction refine(result) {\n\t\t\tvar apply;\n\n\t\t\t['map', 'filter'].forEach(function(method) {\n\t\t\t\tif (method in key) {\n\t\t\t\t\tapply = key[method] instanceof Array ? key[method] : [key[method]];\n\t\t\t\t\tapply.forEach(function(name) {\n\t\t\t\t\t\tif (typeof model[name] === 'function') {\n\t\t\t\t\t\t\tresult = result[method](model[name]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof window[name] === 'function') {\n\t\t\t\t\t\t\tresult = result[method](window[name]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(name + ' is not a ' + method + ' function');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction update() {\n\t\t\tvar output = document.createDocumentFragment(),\n\t\t\t\tties = [],\n\t\t\t\tcollection = model[target];\n\n\t\t\tif (typeof key === 'object') {\n\t\t\t\tcollection = refine(collection);\n\t\t\t}\n\n\t\t\tcollection.forEach(function(value, index) {\n\t\t\t\tvar item = typeof value === 'object' ? value : {},\n\t\t\t\t\targ = [item],\n\t\t\t\t\ti;\n\n\t\t\t\titem.$item   = value;\n\t\t\t\titem.$parent = model[key];\n\t\t\t\titem.$index  = index;\n\n\t\t\t\tfor (i = 0; i < template.length; ++i) {\n\t\t\t\t\targ.push(output.appendChild(template[i].cloneNode(true)));\n\t\t\t\t}\n\n\t\t\t\t//  keep track of the `tie`, so these can be applied once the document fragment\n\t\t\t\t//  is appended to the DOM\n\t\t\t\tties.push(function() {\n\t\t\t\t\tknot.tie.apply(knot, arg);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t//  clear the element and redraw the new output\n\t\t\twhile (element.lastChild) {\n\t\t\t\telement.removeChild(element.lastChild);\n\t\t\t}\n\t\t\telement.appendChild(output);\n\n\t\t\t//  call all of the stored `ties`\n\t\t\tties.forEach(function(tie) {\n\t\t\t\ttie();\n\t\t\t});\n\t\t}\n\n\t\tdelegated.subscribe(function() {\n\t\t\tupdate();\n\t\t});\n\n\t\tupdate();\n\t});\n\n\t//END INCLUDE: extension/each [149.38µs, 1.98KB]\n\t//BEGIN INCLUDE: extension/event\n\tregister('event', function(element, model, config, delegation) {\n\t\t'use strict';\n\n\t\tObject.keys(config)\n\t\t\t.forEach(function(key) {\n\t\t\t\tvar part = typeof config[key] === 'string' ? config[key].split('.') : [],\n\t\t\t\t\tscope = model;\n\n\t\t\t\twhile (part.length) {\n\t\t\t\t\tif (part[0] in scope) {\n\t\t\t\t\t\tscope = scope[part[0]];\n\t\t\t\t\t}\n\n\t\t\t\t\tpart.shift();\n\t\t\t\t}\n\n\t\t\t\telement.addEventListener(key, function(e) {\n\t\t\t\t\tif (typeof scope === 'function') {\n\t\t\t\t\t\tscope.apply(model, [e, model, config[key]]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof scope === 'object' && !(scope[config[key]] instanceof Array)) {\n\t\t\t\t\t\tObject.keys(config[key])\n\t\t\t\t\t\t\t.forEach(function(k) {\n\t\t\t\t\t\t\t\tvar delegated = k in scope ? delegation(scope, k) : null;\n\n\t\t\t\t\t\t\t\tif (delegated) {\n\t\t\t\t\t\t\t\t\tdelegated(config[key][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t})\n\t\t;\n\t});\n\n\t//END INCLUDE: extension/event [99.54µs, 805.00bytes]\n\t//BEGIN INCLUDE: extension/input\n\tregister('input', function(element, model, key, delegation) {\n\t\tvar handler = {},\n\t\t\tproperty, delegated;\n\n\t\tfunction type(node) {\n\t\t\treturn 'type' in node ? node.type : (/^select/i.test(node.nodeName) ? 'select-' + (node.multiple ? 'multiple' : 'one') : 'text');\n\t\t}\n\n\t\tfunction handle(property) {\n\t\t\tif (!(property in handler)) {\n\t\t\t\thandler[property] = {\n\t\t\t\t\tmodel: function() {\n\t\t\t\t\t\tdelegated(element[property]);\n\t\t\t\t\t},\n\t\t\t\t\telement: function(value) {\n\t\t\t\t\t\telement[property] = value;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn handler[property];\n\t\t}\n\n\t\tfunction selection() {\n\t\t\tvar defaultOption = 'default' in key ? {value: null, label: key['default']} : false,\n\t\t\t\tupdate = function() {\n\t\t\t\t\tvar offset = 0;\n\n\t\t\t\t\tif ('options' in key && key.options in model) {\n\t\t\t\t\t\tif (defaultOption) {\n\t\t\t\t\t\t\telement.options[offset] = new Option(defaultOption.label, defaultOption.value);\n\t\t\t\t\t\t\t++offset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement.options.length = offset;\n\n\t\t\t\t\t\tif (typeof model[key.options] === 'object') {\n\t\t\t\t\t\t\tif (model[key.options] instanceof Array) {\n\t\t\t\t\t\t\t\tmodel[key.options]\n\t\t\t\t\t\t\t\t\t.forEach(function(value, index) {\n\t\t\t\t\t\t\t\t\t\tif (typeof value === 'object') {\n\t\t\t\t\t\t\t\t\t\t\telement.options[index + offset] = new Option(value.label || value.value || '', value.value || '');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\telement.options[index + offset] = new Option(value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tObject.keys(model[key.options])\n\t\t\t\t\t\t\t\t\t.forEach(function(value, index) {\n\t\t\t\t\t\t\t\t\t\telement.options[index + offset] = new Option(model[key.options][value], value);\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.options.length && delegated) {\n\t\t\t\t\t\tdelegated(element.options[element.selectedIndex].value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tselect = function(value) {\n\t\t\t\t\tvar i;\n\n\t\t\t\t\tfor (i = 0; i < element.options.length; ++i) {\n\t\t\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\t\t\telement.options[i].selected = value.indexOf(element.options[i].value) >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\telement.options[i].selected = element.options[i].value === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegatedList = 'options' in key ? delegation(model, key.options) : false,\n\t\t\t\tdelegated = 'value' in key ? delegation(model, key.value) : false,\n\t\t\t\tinitial = delegated ? delegated() : null;\n\n\t\t\tif (delegatedList) {\n\t\t\t\tdelegatedList.subscribe(function(change) {\n\t\t\t\t\tupdate();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!delegated && 'value' in key) {\n\t\t\t\tdelegated = knot.delegate(element.hasAttribute('multiple') ? [] : '');\n\t\t\t\tObject.defineProperty(model, key.value, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: delegated,\n\t\t\t\t\tset: delegated\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (delegated) {\n\t\t\t\tif (initial instanceof Array) {\n\t\t\t\t\telement.setAttribute('multiple', '');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telement.removeAttribute('multiple');\n\t\t\t\t}\n\n\t\t\t\telement.addEventListener('change', function(e) {\n\t\t\t\t\tif (element.options.length) {\n\t\t\t\t\t\tdelegated(element.options[element.selectedIndex].value);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\tdelegated.subscribe(select);\n\t\t\t}\n\n\t\t\tif (delegatedList || delegated) {\n\t\t\t\tupdate();\n\t\t\t\tselect(initial);\n\t\t\t}\n\t\t}\n\n\t\tswitch (type(element)) {\n\t\t\tcase 'checkbox':\n\t\t\tcase 'radio':\n\t\t\t\tproperty = 'checked';\n\t\t\t\tbreak;\n\n\t\t\tcase 'select':\n\t\t\tcase 'select-one':\n\t\t\tcase 'select-multiple':\n\t\t\t\t//  select boxes are a very special kind of input, these must be handled differently\n\t\t\t\tselection();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tproperty = 'value'\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (property) {\n\t\t\tdelegated = delegation(model, key[property]);\n\t\t\tif (delegated) {\n\t\t\t\telement.addEventListener('input', handle(property).model, false);\n\t\t\t\telement.addEventListener('change', handle(property).model, false);\n\t\t\t\tdelegated.subscribe(handle(property).element);\n\n\t\t\t\telement[property] = delegated();\n\t\t\t}\n\t\t}\n\t});\n\n\t//END INCLUDE: extension/input [205.39µs, 3.54KB]\n});\n"],"sourceRoot":"/source/"}